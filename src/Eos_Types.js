// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Eosjs = require("eosjs");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var BigNumber = require("@sagan-software/bs-bignumber/src/BigNumber.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var BignumberJs = require("bignumber.js");

function MakeOpaqueStringType() {
  var fromString = function (t) {
    return t;
  };
  var toString = function (t) {
    return t;
  };
  var decode = function (param) {
    return Json_decode.map(fromString, Json_decode.string, param);
  };
  var encode = function (d) {
    return d;
  };
  var isEmpty = function (t) {
    return t.trim().length === 0;
  };
  var areEqual = Caml_obj.caml_equal;
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromString */fromString,
          /* toString */toString,
          /* isEmpty */isEmpty
        ];
}

function MakeOpaqueIntType() {
  var fromInt = function (t) {
    return t;
  };
  var toInt = function (t) {
    return t;
  };
  var decode = function (param) {
    return Json_decode.map(fromInt, Json_decode.$$int, param);
  };
  var encode = function (d) {
    return d;
  };
  var areEqual = Caml_obj.caml_equal;
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromInt */fromInt,
          /* toInt */toInt
        ];
}

function MakeChecksum256Type() {
  var fromString = function (t) {
    return t;
  };
  var toString = function (t) {
    return t;
  };
  var decode = function (param) {
    return Json_decode.map(fromString, Json_decode.string, param);
  };
  var encode = function (d) {
    return d;
  };
  var isEmpty = function (t) {
    return t.trim().length === 0;
  };
  var areEqual = Caml_obj.caml_equal;
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromString */fromString,
          /* toString */toString,
          /* isEmpty */isEmpty
        ];
}

function MakeChecksum160Type() {
  var fromString = function (t) {
    return t;
  };
  var toString = function (t) {
    return t;
  };
  var decode = function (param) {
    return Json_decode.map(fromString, Json_decode.string, param);
  };
  var encode = function (d) {
    return d;
  };
  var isEmpty = function (t) {
    return t.trim().length === 0;
  };
  var areEqual = Caml_obj.caml_equal;
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromString */fromString,
          /* toString */toString,
          /* isEmpty */isEmpty
        ];
}

function MakeChecksum512() {
  var fromString = function (t) {
    return t;
  };
  var toString = function (t) {
    return t;
  };
  var decode = function (param) {
    return Json_decode.map(fromString, Json_decode.string, param);
  };
  var encode = function (d) {
    return d;
  };
  var isEmpty = function (t) {
    return t.trim().length === 0;
  };
  var areEqual = Caml_obj.caml_equal;
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromString */fromString,
          /* toString */toString,
          /* isEmpty */isEmpty
        ];
}

function MakeNameType() {
  var fromString = function (t) {
    return t;
  };
  var toString = function (t) {
    return t;
  };
  var decode = function (param) {
    return Json_decode.map(fromString, Json_decode.string, param);
  };
  var encode = function (d) {
    return d;
  };
  var isEmpty = function (t) {
    return t.trim().length === 0;
  };
  var areEqual = Caml_obj.caml_equal;
  var resultFromString = function (str) {
    if (str.trim().length === 0) {
      return /* Error */Block.__(1, ["Empty string is not a name"]);
    } else if (str.replace((/\./g), "").trim().length === 0) {
      return /* Error */Block.__(1, ["Names must include characters other than dots"]);
    } else {
      var exit = 0;
      var _encoded;
      try {
        _encoded = Eosjs.modules.format.encodeName(str);
        exit = 1;
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Js_exn.$$Error) {
          var match = exn[1].message;
          return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
        } else {
          throw exn;
        }
      }
      if (exit === 1) {
        return /* Ok */Block.__(0, [str]);
      }
      
    }
  };
  var optionFromString = function (str) {
    var match = resultFromString(str);
    if (match.tag) {
      return undefined;
    } else {
      return Js_primitive.some(match[0]);
    }
  };
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromString */fromString,
          /* toString */toString,
          /* isEmpty */isEmpty,
          /* resultFromString */resultFromString,
          /* optionFromString */optionFromString
        ];
}

function fromString(t) {
  return t;
}

function toString(t) {
  return t;
}

function decode(param) {
  return Json_decode.map(fromString, Json_decode.string, param);
}

function encode(d) {
  return d;
}

function isEmpty(t) {
  return t.trim().length === 0;
}

var areEqual = Caml_obj.caml_equal;

function resultFromString(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString(str) {
  var match = resultFromString(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var AccountName = /* module */[
  /* decode */decode,
  /* encode */encode,
  /* areEqual */areEqual,
  /* fromString */fromString,
  /* toString */toString,
  /* isEmpty */isEmpty,
  /* resultFromString */resultFromString,
  /* optionFromString */optionFromString
];

function fromString$1(t) {
  return t;
}

function toString$1(t) {
  return t;
}

function decode$1(param) {
  return Json_decode.map(fromString$1, Json_decode.string, param);
}

function encode$1(d) {
  return d;
}

function isEmpty$1(t) {
  return t.trim().length === 0;
}

var areEqual$1 = Caml_obj.caml_equal;

function resultFromString$1(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString$1(str) {
  var match = resultFromString$1(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var PermissionName = /* module */[
  /* decode */decode$1,
  /* encode */encode$1,
  /* areEqual */areEqual$1,
  /* fromString */fromString$1,
  /* toString */toString$1,
  /* isEmpty */isEmpty$1,
  /* resultFromString */resultFromString$1,
  /* optionFromString */optionFromString$1
];

function fromString$2(t) {
  return t;
}

function toString$2(t) {
  return t;
}

function decode$2(param) {
  return Json_decode.map(fromString$2, Json_decode.string, param);
}

function encode$2(d) {
  return d;
}

function isEmpty$2(t) {
  return t.trim().length === 0;
}

var areEqual$2 = Caml_obj.caml_equal;

function resultFromString$2(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString$2(str) {
  var match = resultFromString$2(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var TokenName = /* module */[
  /* decode */decode$2,
  /* encode */encode$2,
  /* areEqual */areEqual$2,
  /* fromString */fromString$2,
  /* toString */toString$2,
  /* isEmpty */isEmpty$2,
  /* resultFromString */resultFromString$2,
  /* optionFromString */optionFromString$2
];

function fromString$3(t) {
  return t;
}

function toString$3(t) {
  return t;
}

function decode$3(param) {
  return Json_decode.map(fromString$3, Json_decode.string, param);
}

function encode$3(d) {
  return d;
}

function isEmpty$3(t) {
  return t.trim().length === 0;
}

var areEqual$3 = Caml_obj.caml_equal;

function resultFromString$3(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString$3(str) {
  var match = resultFromString$3(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var TableName = /* module */[
  /* decode */decode$3,
  /* encode */encode$3,
  /* areEqual */areEqual$3,
  /* fromString */fromString$3,
  /* toString */toString$3,
  /* isEmpty */isEmpty$3,
  /* resultFromString */resultFromString$3,
  /* optionFromString */optionFromString$3
];

function fromString$4(t) {
  return t;
}

function toString$4(t) {
  return t;
}

function decode$4(param) {
  return Json_decode.map(fromString$4, Json_decode.string, param);
}

function encode$4(d) {
  return d;
}

function isEmpty$4(t) {
  return t.trim().length === 0;
}

var areEqual$4 = Caml_obj.caml_equal;

function resultFromString$4(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString$4(str) {
  var match = resultFromString$4(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var ScopeName = /* module */[
  /* decode */decode$4,
  /* encode */encode$4,
  /* areEqual */areEqual$4,
  /* fromString */fromString$4,
  /* toString */toString$4,
  /* isEmpty */isEmpty$4,
  /* resultFromString */resultFromString$4,
  /* optionFromString */optionFromString$4
];

function fromString$5(t) {
  return t;
}

function toString$5(t) {
  return t;
}

function decode$5(param) {
  return Json_decode.map(fromString$5, Json_decode.string, param);
}

function encode$5(d) {
  return d;
}

function isEmpty$5(t) {
  return t.trim().length === 0;
}

var areEqual$5 = Caml_obj.caml_equal;

function resultFromString$5(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString$5(str) {
  var match = resultFromString$5(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var ActionName = /* module */[
  /* decode */decode$5,
  /* encode */encode$5,
  /* areEqual */areEqual$5,
  /* fromString */fromString$5,
  /* toString */toString$5,
  /* isEmpty */isEmpty$5,
  /* resultFromString */resultFromString$5,
  /* optionFromString */optionFromString$5
];

function fromString$6(t) {
  return t;
}

function toString$6(t) {
  return t;
}

function decode$6(param) {
  return Json_decode.map(fromString$6, Json_decode.string, param);
}

function encode$6(d) {
  return d;
}

function isEmpty$6(t) {
  return t.trim().length === 0;
}

var areEqual$6 = Caml_obj.caml_equal;

function resultFromString$6(str) {
  if (str.trim().length === 0) {
    return /* Error */Block.__(1, ["Empty string is not a name"]);
  } else if (str.replace((/\./g), "").trim().length === 0) {
    return /* Error */Block.__(1, ["Names must include characters other than dots"]);
  } else {
    var exit = 0;
    var _encoded;
    try {
      _encoded = Eosjs.modules.format.encodeName(str);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Js_exn.$$Error) {
        var match = exn[1].message;
        return /* Error */Block.__(1, [match !== undefined ? match : "Could not convert \"" + (String(str) + "\" to a name type")]);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Ok */Block.__(0, [str]);
    }
    
  }
}

function optionFromString$6(str) {
  var match = resultFromString$6(str);
  if (match.tag) {
    return undefined;
  } else {
    return Js_primitive.some(match[0]);
  }
}

var TypeName = /* module */[
  /* decode */decode$6,
  /* encode */encode$6,
  /* areEqual */areEqual$6,
  /* fromString */fromString$6,
  /* toString */toString$6,
  /* isEmpty */isEmpty$6,
  /* resultFromString */resultFromString$6,
  /* optionFromString */optionFromString$6
];

function MakeOpaqueDateType(Args) {
  var fromDate = function (date) {
    return /* tuple */[
            Curry._1(Args[/* fromDate */0], date),
            date
          ];
  };
  var toDate = function (param) {
    return param[1];
  };
  var decode = function (j) {
    var $$native = Curry._1(Args[/* decode */2], j);
    var date = Curry._1(Args[/* toDate */1], $$native);
    var match = isNaN(date);
    var date$1 = match ? new Date(0) : date;
    return /* tuple */[
            $$native,
            date$1
          ];
  };
  var encode = function (param) {
    return Curry._1(Args[/* encode */3], param[0]);
  };
  var isEmpty = function (param) {
    return param[1].getTime() === 0;
  };
  var areEqual = function (param, param$1) {
    return param[1].getTime() === param$1[1].getTime();
  };
  return /* module */[
          /* decode */decode,
          /* encode */encode,
          /* areEqual */areEqual,
          /* fromDate */fromDate,
          /* toDate */toDate,
          /* isEmpty */isEmpty
        ];
}

function fromDate(t) {
  return t.toISOString().slice(0, -1);
}

function fromDate$1(date) {
  return /* tuple */[
          fromDate(date),
          date
        ];
}

function toDate(param) {
  return param[1];
}

function decode$7(j) {
  var $$native = Json_decode.string(j);
  var date = new Date($$native + "Z");
  var match = isNaN(date);
  var date$1 = match ? new Date(0) : date;
  return /* tuple */[
          $$native,
          date$1
        ];
}

function encode$7(param) {
  return param[0];
}

function isEmpty$7(param) {
  return param[1].getTime() === 0;
}

function areEqual$7(param, param$1) {
  return param[1].getTime() === param$1[1].getTime();
}

var BlockTimestamp = /* module */[
  /* decode */decode$7,
  /* encode */encode$7,
  /* areEqual */areEqual$7,
  /* fromDate */fromDate$1,
  /* toDate */toDate,
  /* isEmpty */isEmpty$7
];

function toDate$1(t) {
  return new Date(t.div(1000).toNumber());
}

function fromDate$2(date) {
  return /* tuple */[
          new BignumberJs(date.getTime()),
          date
        ];
}

function toDate$2(param) {
  return param[1];
}

function decode$8(j) {
  var $$native = BigNumber.decode(j);
  var date = toDate$1($$native);
  var match = isNaN(date);
  var date$1 = match ? new Date(0) : date;
  return /* tuple */[
          $$native,
          date$1
        ];
}

function encode$8(param) {
  return BigNumber.encode(param[0]);
}

function isEmpty$8(param) {
  return param[1].getTime() === 0;
}

function areEqual$8(param, param$1) {
  return param[1].getTime() === param$1[1].getTime();
}

var TimePoint = /* module */[
  /* decode */decode$8,
  /* encode */encode$8,
  /* areEqual */areEqual$8,
  /* fromDate */fromDate$2,
  /* toDate */toDate$2,
  /* isEmpty */isEmpty$8
];

function fromString$7(t) {
  return t;
}

function toString$7(t) {
  return t;
}

function decode$9(param) {
  return Json_decode.map(fromString$7, Json_decode.string, param);
}

function encode$9(d) {
  return d;
}

function isEmpty$9(t) {
  return t.trim().length === 0;
}

var areEqual$9 = Caml_obj.caml_equal;

function isValid(t) {
  return Eosjs.modules.ecc.isValidPublic(t);
}

var PublicKey = /* module */[
  /* decode */decode$9,
  /* encode */encode$9,
  /* areEqual */areEqual$9,
  /* fromString */fromString$7,
  /* toString */toString$7,
  /* isEmpty */isEmpty$9,
  /* isValid */isValid
];

function fromString$8(t) {
  return t;
}

function toString$8(t) {
  return t;
}

function decode$10(param) {
  return Json_decode.map(fromString$8, Json_decode.string, param);
}

function encode$10(d) {
  return d;
}

function isEmpty$10(t) {
  return t.trim().length === 0;
}

var areEqual$10 = Caml_obj.caml_equal;

function isValid$1(t) {
  return Eosjs.modules.ecc.isValidPrivate(t);
}

function toPublic(t) {
  return Eosjs.modules.ecc.privateToPublic(t);
}

var PrivateKey = /* module */[
  /* decode */decode$10,
  /* encode */encode$10,
  /* areEqual */areEqual$10,
  /* fromString */fromString$8,
  /* toString */toString$8,
  /* isEmpty */isEmpty$10,
  /* isValid */isValid$1,
  /* toPublic */toPublic
];

function decode$11(param) {
  return Json_decode.map((function (prim) {
                return Eosjs.modules.format.parseAsset(prim);
              }), Json_decode.string, param);
}

function encode$11(d) {
  return Eosjs.modules.format.printAsset(d);
}

var Asset = /* module */[
  /* decode */decode$11,
  /* encode */encode$11
];

function asset(prim) {
  return Eosjs.modules.format.parseAsset(prim);
}

function fromString$9(t) {
  return t;
}

function toString$9(t) {
  return t;
}

function decode$12(param) {
  return Json_decode.map(fromString$9, Json_decode.string, param);
}

function encode$12(d) {
  return d;
}

function isEmpty$11(t) {
  return t.trim().length === 0;
}

var areEqual$11 = Caml_obj.caml_equal;

var MerkleRoot = /* module */[
  /* decode */decode$12,
  /* encode */encode$12,
  /* areEqual */areEqual$11,
  /* fromString */fromString$9,
  /* toString */toString$9,
  /* isEmpty */isEmpty$11
];

function fromString$10(t) {
  return t;
}

function toString$10(t) {
  return t;
}

function decode$13(param) {
  return Json_decode.map(fromString$10, Json_decode.string, param);
}

function encode$13(d) {
  return d;
}

function isEmpty$12(t) {
  return t.trim().length === 0;
}

var areEqual$12 = Caml_obj.caml_equal;

var Signature = /* module */[
  /* decode */decode$13,
  /* encode */encode$13,
  /* areEqual */areEqual$12,
  /* fromString */fromString$10,
  /* toString */toString$10,
  /* isEmpty */isEmpty$12
];

function fromString$11(t) {
  return t;
}

function toString$11(t) {
  return t;
}

function decode$14(param) {
  return Json_decode.map(fromString$11, Json_decode.string, param);
}

function encode$14(d) {
  return d;
}

function isEmpty$13(t) {
  return t.trim().length === 0;
}

var areEqual$13 = Caml_obj.caml_equal;

var BlockId = /* module */[
  /* decode */decode$14,
  /* encode */encode$14,
  /* areEqual */areEqual$13,
  /* fromString */fromString$11,
  /* toString */toString$11,
  /* isEmpty */isEmpty$13
];

function fromString$12(t) {
  return t;
}

function toString$12(t) {
  return t;
}

function decode$15(param) {
  return Json_decode.map(fromString$12, Json_decode.string, param);
}

function encode$15(d) {
  return d;
}

function isEmpty$14(t) {
  return t.trim().length === 0;
}

var areEqual$14 = Caml_obj.caml_equal;

var TransactionId = /* module */[
  /* decode */decode$15,
  /* encode */encode$15,
  /* areEqual */areEqual$14,
  /* fromString */fromString$12,
  /* toString */toString$12,
  /* isEmpty */isEmpty$14
];

function decode$16(x) {
  return /* record */[
          /* account */Json_decode.field("account", decode, x),
          /* permission */Json_decode.field("permission", decode$1, x)
        ];
}

function encode$16(x) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "account",
                x[/* account */0]
              ],
              /* :: */[
                /* tuple */[
                  "permission",
                  x[/* permission */1]
                ],
                /* [] */0
              ]
            ]);
}

var AccountPermission = /* module */[
  /* decode */decode$16,
  /* encode */encode$16
];

exports.MakeOpaqueStringType = MakeOpaqueStringType;
exports.MakeOpaqueIntType = MakeOpaqueIntType;
exports.MakeChecksum256Type = MakeChecksum256Type;
exports.MakeChecksum160Type = MakeChecksum160Type;
exports.MakeChecksum512 = MakeChecksum512;
exports.MakeNameType = MakeNameType;
exports.AccountName = AccountName;
exports.PermissionName = PermissionName;
exports.TokenName = TokenName;
exports.TableName = TableName;
exports.ScopeName = ScopeName;
exports.ActionName = ActionName;
exports.TypeName = TypeName;
exports.MakeOpaqueDateType = MakeOpaqueDateType;
exports.BlockTimestamp = BlockTimestamp;
exports.TimePoint = TimePoint;
exports.PublicKey = PublicKey;
exports.PrivateKey = PrivateKey;
exports.Asset = Asset;
exports.asset = asset;
exports.MerkleRoot = MerkleRoot;
exports.Signature = Signature;
exports.BlockId = BlockId;
exports.TransactionId = TransactionId;
exports.AccountPermission = AccountPermission;
/* eosjs Not a pure module */
